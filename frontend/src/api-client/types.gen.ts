// This file is auto-generated by @hey-api/openapi-ts

export type Party = {
    entity: {
        [key: string]: Array<string>;
    };
    access: {
        [key: string]: Array<string>;
    };
};

export type Period = {
    days: number;
    weeks: number;
    months: number;
    years: number;
};

export type _Error = {
    errorType?: string;
    id?: string;
    idType?: string;
    message?: string;
    error?: string | null;
    origin?: {
        value?: string;
        code?: number;
        originType?: string;
        id?: string;
        message?: string;
    } | null;
    stackTrace?: string | null;
    clientStackTrace?: Array<{
        name?: string;
        protocolId?: string | null;
        elementType?: string;
        location?: {
            file?: string;
            line?: number;
            sourceRef?: {
                path?: string;
                commit?: string;
            } | null;
        };
    } | null> | null;
};

export type BlockchainDeployResponse = {
    status: BlockchainStatus;
    contractAddress: string | null;
    errorCode: string | null;
    details: string | null;
};

export type BlockchainFunctionResponse = {
    status: BlockchainStatus;
    hash: string | null;
    errorCode: string | null;
    details: string | null;
};

export type BlockchainStatus = 'Success' | 'Failure';

export type SmartContractReference = string;

export type BlockchainDeployResponseNotification = {
    type: 'success' | 'failure';
    value?: BlockchainDeployResponse;
};

export type BlockchainFunctionResponseNotification = {
    type: 'success' | 'failure';
    value?: BlockchainFunctionResponse;
};

export type Device = {
    '@id': string;
    '@parties': DeviceParties;
    '@actions': DeviceActions;
    numbers: Array<number>;
    key: string;
    smartContract: SmartContractReference;
    customerWalletAddress: string;
};

export type DeviceParties = {
    deviceManager: Party;
    iotDevice: Party;
    blockchain_worker: Party;
};

export type DeviceActions = {
    submitEvent?: string;
    callback?: string;
};

export type DeviceList = {
    '@prev'?: string;
    '@next'?: string;
    items: Array<Device>;
    page?: number;
    /**
     * Total number of accessible protocol instances. Only included if the `includeCount` query parameter was set.
     */
    totalItems?: number | null;
    /**
     * Total number of accessible pages. Only included if the `includeCount` query parameter was set.
     */
    totalPages?: number | null;
};

export type DeviceCreate = {
    key: string;
    smartContract: SmartContractReference;
    customerWalletAddress: string;
    '@parties': DeviceParties;
};

export type DeviceSubmitEventCommand = {
    number: number;
};

export type DeviceCallbackCommand = {
    res: BlockchainFunctionResponseNotification;
};

export type Setup = {
    '@id': string;
    '@parties': SetupParties;
    '@actions': SetupActions;
};

export type SetupParties = {
    system: Party;
};

export type SetupActions = {
    [key: string]: unknown;
};

export type SetupList = {
    '@prev'?: string;
    '@next'?: string;
    items: Array<Setup>;
    page?: number;
    /**
     * Total number of accessible protocol instances. Only included if the `includeCount` query parameter was set.
     */
    totalItems?: number | null;
    /**
     * Total number of accessible pages. Only included if the `includeCount` query parameter was set.
     */
    totalPages?: number | null;
};

export type SmartContract = {
    '@id': string;
    '@parties': SmartContractParties;
    '@actions': SmartContractActions;
    '@state': SmartContractStates;
    tokenContractAddress: string;
    tokenContractDeploymentError: string | null;
    tokenContractDeploymentDate: string | null;
    ownerWalletAddress: string;
    customerWalletAddresses: Array<string>;
};

export type SmartContractParties = {
    worker: Party;
};

export type SmartContractActions = {
    contractDeploymentCallback?: string;
};

export type SmartContractList = {
    '@prev'?: string;
    '@next'?: string;
    items: Array<SmartContract>;
    page?: number;
    /**
     * Total number of accessible protocol instances. Only included if the `includeCount` query parameter was set.
     */
    totalItems?: number | null;
    /**
     * Total number of accessible pages. Only included if the `includeCount` query parameter was set.
     */
    totalPages?: number | null;
};

export type SmartContractCreate = {
    ownerWalletAddress: string;
    customerWalletAddresses: Array<string>;
    '@parties': SmartContractParties;
};

export type SmartContractStates = 'pending' | 'deployed' | 'failed';

export type SmartContractContractDeploymentCallbackCommand = {
    res: BlockchainDeployResponseNotification;
};

/**
 * Optional parameter to require a specific API version
 */
export type ApiVersion = string;

/**
 * Optional parameter to require a specific NPL Tag
 */
export type NplTag = string;

export type ProtocolId = string;

export type GetOpenApiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/npl/iot_steering/-/openapi.json';
};

export type GetOpenApiResponses = {
    /**
     * The OpenAPI spec
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetOpenApiResponse = GetOpenApiResponses[keyof GetOpenApiResponses];

export type GetDeviceListData = {
    body?: never;
    headers?: {
        /**
         * Optional parameter to require a specific API version
         */
        'X-NPL-API'?: string;
        /**
         * Optional parameter to require a specific NPL Tag
         */
        'X-NPL-TAG'?: string;
    };
    path?: never;
    query?: {
        page?: number;
        pageSize?: number;
        /**
         * Include `totalItems` and `totalPages` in the response if set. This option is very expensive, so should be avoided when possible.
         */
        includeCount?: boolean;
    };
    url: '/npl/iot_steering/Device/';
};

export type GetDeviceListErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetDeviceListError = GetDeviceListErrors[keyof GetDeviceListErrors];

export type GetDeviceListResponses = {
    /**
     * All accessible protocol instances of this type
     */
    200: DeviceList;
};

export type GetDeviceListResponse = GetDeviceListResponses[keyof GetDeviceListResponses];

export type CreateDeviceData = {
    body: DeviceCreate;
    headers?: {
        /**
         * Optional parameter to require a specific API version
         */
        'X-NPL-API'?: string;
        /**
         * Optional parameter to require a specific NPL Tag
         */
        'X-NPL-TAG'?: string;
    };
    path?: never;
    query?: never;
    url: '/npl/iot_steering/Device/';
};

export type CreateDeviceErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type CreateDeviceError = CreateDeviceErrors[keyof CreateDeviceErrors];

export type CreateDeviceResponses = {
    /**
     * The new protocol instance
     */
    200: Device;
    /**
     * No Content
     */
    204: void;
};

export type CreateDeviceResponse = CreateDeviceResponses[keyof CreateDeviceResponses];

export type GetDeviceByIdData = {
    body?: never;
    headers?: {
        /**
         * Optional parameter to require a specific API version
         */
        'X-NPL-API'?: string;
        /**
         * Optional parameter to require a specific NPL Tag
         */
        'X-NPL-TAG'?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/npl/iot_steering/Device/{id}/';
};

export type GetDeviceByIdErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetDeviceByIdError = GetDeviceByIdErrors[keyof GetDeviceByIdErrors];

export type GetDeviceByIdResponses = {
    /**
     * The protocol instance with this ID
     */
    200: Device;
};

export type GetDeviceByIdResponse = GetDeviceByIdResponses[keyof GetDeviceByIdResponses];

export type DeviceSubmitEventData = {
    body: DeviceSubmitEventCommand;
    headers?: {
        /**
         * Optional parameter to require a specific API version
         */
        'X-NPL-API'?: string;
        /**
         * Optional parameter to require a specific NPL Tag
         */
        'X-NPL-TAG'?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/npl/iot_steering/Device/{id}/submitEvent';
};

export type DeviceSubmitEventErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type DeviceSubmitEventError = DeviceSubmitEventErrors[keyof DeviceSubmitEventErrors];

export type DeviceSubmitEventResponses = {
    /**
     * Unit
     */
    200: {
        [key: string]: never;
    };
    /**
     * No Content
     */
    204: void;
};

export type DeviceSubmitEventResponse = DeviceSubmitEventResponses[keyof DeviceSubmitEventResponses];

export type DeviceCallbackData = {
    body: DeviceCallbackCommand;
    headers?: {
        /**
         * Optional parameter to require a specific API version
         */
        'X-NPL-API'?: string;
        /**
         * Optional parameter to require a specific NPL Tag
         */
        'X-NPL-TAG'?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/npl/iot_steering/Device/{id}/callback';
};

export type DeviceCallbackErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type DeviceCallbackError = DeviceCallbackErrors[keyof DeviceCallbackErrors];

export type DeviceCallbackResponses = {
    /**
     * Unit
     */
    200: {
        [key: string]: never;
    };
    /**
     * No Content
     */
    204: void;
};

export type DeviceCallbackResponse = DeviceCallbackResponses[keyof DeviceCallbackResponses];

export type GetSetupListData = {
    body?: never;
    headers?: {
        /**
         * Optional parameter to require a specific API version
         */
        'X-NPL-API'?: string;
        /**
         * Optional parameter to require a specific NPL Tag
         */
        'X-NPL-TAG'?: string;
    };
    path?: never;
    query?: {
        page?: number;
        pageSize?: number;
        /**
         * Include `totalItems` and `totalPages` in the response if set. This option is very expensive, so should be avoided when possible.
         */
        includeCount?: boolean;
    };
    url: '/npl/iot_steering/Setup/';
};

export type GetSetupListErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetSetupListError = GetSetupListErrors[keyof GetSetupListErrors];

export type GetSetupListResponses = {
    /**
     * All accessible protocol instances of this type
     */
    200: SetupList;
};

export type GetSetupListResponse = GetSetupListResponses[keyof GetSetupListResponses];

export type GetSetupByIdData = {
    body?: never;
    headers?: {
        /**
         * Optional parameter to require a specific API version
         */
        'X-NPL-API'?: string;
        /**
         * Optional parameter to require a specific NPL Tag
         */
        'X-NPL-TAG'?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/npl/iot_steering/Setup/{id}/';
};

export type GetSetupByIdErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetSetupByIdError = GetSetupByIdErrors[keyof GetSetupByIdErrors];

export type GetSetupByIdResponses = {
    /**
     * The protocol instance with this ID
     */
    200: Setup;
};

export type GetSetupByIdResponse = GetSetupByIdResponses[keyof GetSetupByIdResponses];

export type GetSmartContractListData = {
    body?: never;
    headers?: {
        /**
         * Optional parameter to require a specific API version
         */
        'X-NPL-API'?: string;
        /**
         * Optional parameter to require a specific NPL Tag
         */
        'X-NPL-TAG'?: string;
    };
    path?: never;
    query?: {
        page?: number;
        pageSize?: number;
        /**
         * Include `totalItems` and `totalPages` in the response if set. This option is very expensive, so should be avoided when possible.
         */
        includeCount?: boolean;
    };
    url: '/npl/iot_steering/SmartContract/';
};

export type GetSmartContractListErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetSmartContractListError = GetSmartContractListErrors[keyof GetSmartContractListErrors];

export type GetSmartContractListResponses = {
    /**
     * All accessible protocol instances of this type
     */
    200: SmartContractList;
};

export type GetSmartContractListResponse = GetSmartContractListResponses[keyof GetSmartContractListResponses];

export type CreateSmartContractData = {
    body: SmartContractCreate;
    headers?: {
        /**
         * Optional parameter to require a specific API version
         */
        'X-NPL-API'?: string;
        /**
         * Optional parameter to require a specific NPL Tag
         */
        'X-NPL-TAG'?: string;
    };
    path?: never;
    query?: never;
    url: '/npl/iot_steering/SmartContract/';
};

export type CreateSmartContractErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type CreateSmartContractError = CreateSmartContractErrors[keyof CreateSmartContractErrors];

export type CreateSmartContractResponses = {
    /**
     * The new protocol instance
     */
    200: SmartContract;
    /**
     * No Content
     */
    204: void;
};

export type CreateSmartContractResponse = CreateSmartContractResponses[keyof CreateSmartContractResponses];

export type GetSmartContractByIdData = {
    body?: never;
    headers?: {
        /**
         * Optional parameter to require a specific API version
         */
        'X-NPL-API'?: string;
        /**
         * Optional parameter to require a specific NPL Tag
         */
        'X-NPL-TAG'?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/npl/iot_steering/SmartContract/{id}/';
};

export type GetSmartContractByIdErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetSmartContractByIdError = GetSmartContractByIdErrors[keyof GetSmartContractByIdErrors];

export type GetSmartContractByIdResponses = {
    /**
     * The protocol instance with this ID
     */
    200: SmartContract;
};

export type GetSmartContractByIdResponse = GetSmartContractByIdResponses[keyof GetSmartContractByIdResponses];

export type SmartContractContractDeploymentCallbackData = {
    body: SmartContractContractDeploymentCallbackCommand;
    headers?: {
        /**
         * Optional parameter to require a specific API version
         */
        'X-NPL-API'?: string;
        /**
         * Optional parameter to require a specific NPL Tag
         */
        'X-NPL-TAG'?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/npl/iot_steering/SmartContract/{id}/contractDeploymentCallback';
};

export type SmartContractContractDeploymentCallbackErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type SmartContractContractDeploymentCallbackError = SmartContractContractDeploymentCallbackErrors[keyof SmartContractContractDeploymentCallbackErrors];

export type SmartContractContractDeploymentCallbackResponses = {
    /**
     * Unit
     */
    200: {
        [key: string]: never;
    };
    /**
     * No Content
     */
    204: void;
};

export type SmartContractContractDeploymentCallbackResponse = SmartContractContractDeploymentCallbackResponses[keyof SmartContractContractDeploymentCallbackResponses];

export type ClientOptions = {
    baseUrl: 'https://engine.example.com/' | (string & {});
};